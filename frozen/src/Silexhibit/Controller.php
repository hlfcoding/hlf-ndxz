<?php

// Silexhibit Controller
// =====================
// This is the base controller class. Its main responsibilities include
// mediating between the model, view, and optional components; handling routes
// with action methods; registering application-level common configuration
// option groups; preparing up web assets; and registering templaters.

namespace Silexhibit;

use Silex\Application;
use Symfony\HttpFoundation\Request;

use Igorw\Silex\ConfigServiceProvider;

use Mustache_Engine,
    Mustache_Loader_FilesystemLoader;

use Assetic\Asset\AssetCache,
    Assetic\Asset\AssetCollection,
    Assetic\Asset\FileAsset,
    Assetic\Asset\GlobAsset,
    Assetic\AssetManager,
    Assetic\AssetWriter,
    Assetic\Cache\FilesystemCache,
    Assetic\Factory\AssetFactory,
    Assetic\Factory\Worker\CacheBustingWorker,
    Assetic\Filter\CoffeeScriptFilter,
    Assetic\Filter\GoogleClosure\CompilerApiFilter as JsCompressorFilter,
    Assetic\Filter\Sass\ScssFilter,
    Assetic\Filter\Yui\CssCompressorFilter,
    Assetic\FilterManager;

use Silexhibit\ModelServiceProvider,
    Silexhibit\ViewServiceProvider;

// Required Silex application globals, helpers, and services:
// `debug`, `env`, `url_generator`, `logger`, `mustache`, `merged`, `path`,
// `path.cache`, `config.vars`.

abstract class Controller
{
  // Core Flags
  // ----------
  
  // Internal flag derived from the `debug` Silex global. This can be modified
  // independently by a subclass for Silexhibit application-specific debugging.
  protected $debug;
  // `is_prod` is an internal flag derived from the `env` global. While this can
  // be independently modified by a subclass, doing so is discouraged.
  protected $is_prod;

  // Core Configuration
  // ------------------

  // `app_name` must be set before calling the constructor. For now, the strict
  // convention is a controller represents an application.
  public $app_name;
  // `options` is the final, merged configuration option group. Its base is the
  // merged configuration for `app`, which gets shared by Silexhibit
  // applications. The merged configuration for the application-specific
  // configuration also gets merged in. For documentation on available options,
  // see the respective yml files.
  protected $options;

  // Theme Support
  // -------------
  
  // `is_themable` is a convenience flag for if the Silexhibit application
  // represented by this controller supports theming. If so, additional
  // controller features are available.
  protected $is_themable;
  // `theme_options` is a final, merged configuration option group for
  // `theme.<application>`. For documentation on available options, see the
  // respective yml files.
  protected $theme_options;

  // Bundled Services
  // ----------------
  
  // `url` is a convenience reference to the `url_generator` service.
  protected $url;
  // `logger` is a convenience reference to the namesake service.
  protected $logger;

  // Templaters
  // ----------

  // The dedicated `templater` for this Silexhibit application. If not pre-
  // emptively set by a subclass before calling this constructor, it will be a
  // service based on a `Mustache_Engine` that reads templates and partials from
  // the application's `app_web` path.
  public $templater;
  // `string_templater` is a reference to the `mustache` service, which is an
  // on-the-fly compiler.
  public $string_templater;

  // Component Support
  // -----------------
  // Components are modular extensions of MVC logic that allow Silexhibit
  // application customization. Examples of components in Silexhibit include
  // plugins and widgets. Conventionally, components are generated by dedicated
  // factories. If components can render, they will have dedicated templaters
  // registered.

  // `component_templaters` stores by component name registered
  // `Mustache_Engine`-based services.
  public $component_templaters;
  // `component_factories` stores by component name instances of classes
  // implementing `FactoryInterface`. Conventionally, the factories are created
  // and managed by the controller and used by its view.
  public $component_factories;
  // `component_names` stores the component names and must be set before calling
  // the constructor if component support is desired. Registering a component
  // starts with adding its name to this store. Conventionally, applying an
  // action to all components requires looping through this unsorted list.
  public $component_names;

  // Conveniences
  // ------------

  // `paths` is a cache of path values sometimes defined by `app_name`. Trailing
  // slashes are omitted. See `registerPaths`.
  
  // - `app_web`
  // - `cache`: Asset cache path.
  // - `dist`: Asset dist path.
  // - `lib_web`
  // - `theme_web`
  protected $paths;

  // Frontend Asset Support
  // ----------------------
  // Assetic's API is very composable but slightly monolithic. The base
  // controller only provides a simple, though broad, implementation of
  // application assets. CoffeeScript and Sass processing are supported. Caching
  // is included. Theme support is included. Optional assets support is
  // included. Assets are stored in a conventional folder structure. Extending
  // asset processing is supported through the method hooks
  // `willRegisterCSSAssets` and `willRegisterJSAssets` that can return an
  // extended asset collection as well as a file-name modifier.
  
  // `asset_config` is the final, merged `assetic` configuration option group.
  protected $asset_config;
  // `asset_manager` is the dedicated instance of Assetic's `AssetManager`.
  protected $asset_manager;
  // `asset_factory` is the dedicated instance of Assetic's `AssetFactory`,
  // which keeps track of asset-managers and filter-manages.
  protected $asset_factory;
  // `asset_writer` is the dedicated instance of Assetic's `AssetWriter` and
  // writes the processed and compiled assets to the asset distribution location.
  protected $asset_writer;
  // `asset_cache` is the dedicated instance of Assetic's `FilesystemCache` and
  // stores the processed and compiled assets to the asset cache location.
  // Instances of `AssetCache` are created in reference to it, so `asset_cache`
  // is somewhat of a misnomer.
  protected $asset_cache;
  // `asset_urls` stores the final lists of domain-relative asset distribution
  // URLs per identifiers based on page location and type, initially: `css`,
  // `head_js`, `js`. Conventionally, this store can simply be merged into the
  // template context when rendering the view for the template to output.
  public $asset_urls;

  // Constructor
  // -----------
  public function __construct(Application $app)
  {
    // - Set core flags.
    $this->debug = $app['debug'];
    $this->is_prod = $app['env'] === 'prod';

    // - Alias app name.
    $app_name = $this->app_name;

    // - Setup `paths`, passing dependency container.
    $this->registerPaths($app);
    // - Setup options and set `is_themable`, passing dependency container.
    $this->registerConfig($app);
    // - Setup paths that depend on set up `paths` and `options`.
    $this->paths['theme_web'] = rtrim($app['path.theme_web'](), '/');

    // - Alias services.
    $this->url = $app['url_generator'];
    $this->logger = $app['logger'];
    $this->string_templater = $app['mustache'];

    // - Register default dedicated `templater` if needed.
    if (!isset($this->templater)) {
      $this->templater = $this->registerTemplater(
        $app, 'templater', array(
          'template_path' => "{$this->paths['app_web']}/mustache",
          'partial_path' => "{$this->paths['app_web']}/mustache/partial",
        ));
    }

    // - Setup components support.
    $this->component_factories = array();
    if (!isset($this->component_names)) {
      // - Default to safe value for `component_names` if needed.
      $this->component_names = array();
    } else {
      // - Register a dedicated templater per component if needed.
      $this->registerComponentTemplaters($app);
    }

    // - Setup asset support.
    $this->asset_config = $app['merged']('assetic');
    $this->setupAssets();
  }

  // Model-View Communication
  // ------------------------
  
  // Ideally the model and view should not know about each other. But in certain
  // cases, the proxy logic the controller may need to implement in
  // `provideData` may not be trivial, so `modelForView` and `viewForModel`
  // become an easier alternative. Still, implementing and using these somewhat
  // deprecated methods is mostly discouraged.
  abstract public function modelForView(ViewServiceProvider $view);
  abstract public function viewForModel(ModelServiceProvider $model);
  // Conventionally, if the view needs more data than what's passed into
  // `transform`, it should call its controller's `provideData` and pass in any
  // additional `params` as needed.
  abstract public function provideData($key, array $params=array());

  // Controller-View Communication
  // -----------------------------
  
  // `viewWillRender` is a hook that conventionally should be called by the view
  // before it sets its asset URLs and renders its template. The controller will
  // do any further preparations outside of the specific logic in the action
  // method for the view to fully render.
  public function viewWillRender(ViewServiceProvider $view)
  {
    $this->processAssets();
  }

  // Controller-Subclass Delegation
  // ------------------------------
  
  abstract protected function willRegisterCSSAssets($assets);
  abstract protected function willRegisterJSAssets($assets);

  // Registration Subroutines
  // ------------------------
  
  // In addition to path helper registration, `registerPaths` also provides
  // general path setup. Conventionally, to add more entries to `paths`,
  // overriding and extending `registerPaths` is the cleanest approach..
  protected function registerPaths(Application $app)
  {
    // - Alias.
    $app_name = $this->app_name;
    $app_controller = $this;
    // - Register path helpers.
    $app['path.app_web'] = $app->protect(function ($sub_path='') use ($app, $app_name) {
      return $app['path']("web/{$app_name}/$sub_path");
    });
    $app['path.theme_web'] = $app->protect(function ($sub_path='') use ($app, $app_name, $app_controller) {
      // - Note we need the theme name from `options`.
      return $app_controller->is_themable
        ? $app['path']("web/{$app_name}/{$app['app.opts']['theme']}/$sub_path")
        : $app['path.app_web']();
    });
    // - Populate `paths` using path helper calls with mostly empty sub-paths.
    $this->paths = array(
      'app_web' => rtrim($app['path.app_web'](), '/'),
      'cache' => $app['path.cache']('assetic'),
      'dist' => rtrim($app['path.asset_dist'](), '/'),
      'lib_web' => rtrim($app['path.asset_lib'](), '/'),
    );
  }

  // Conventionally, `registerView` should be called in the action method, after
  // constructing the view. Retaining the view should be handled by the specific
  // controller. However, this method can also be called on controller
  // construction if the view gets used by all or most actions.
  protected function registerView(ViewServiceProvider $view, Application $app)
  {
    // - Register view as service.
    $app->register($view);
    // - Share selected controller properties with the view.
    $view->updateFromController();
    return $view;
  }

  // `registerComponentTemplaters` runs automatically as long as
  // `component_names` is set. The templaters based off of the default ones from
  // `registerTemplater` with the exception of no partials support, since
  // component markup is expected to be simple and not heavily layered. Web
  // paths for the component are expected to be in `paths`. Note that this
  // method doesn't actually register the templater as a service provider, but
  // only for use by the controller.
  protected function registerComponentTemplaters(Application $app)
  {
    foreach ($this->component_names as $component) {
      if (!isset($this->paths["${component}_web"])) {
        # TODO: Log notice.
        continue;
      }
      $this->component_templaters[$component] = $this->registerTemplater(
        $app, "$component.templater", array(
          'template_path' => $this->paths["${component}_web"],
        ));
    }
  }

  // `registerComponentFactories` should be called after registering any
  // component factory service providers. Note that this method doesn't actually
  // register the component factory as a service provider, but only for use by
  // the controller.
  protected function registerComponentFactories(Application $app)
  {
      foreach ($this->component_names as $component) {
        $this->component_factories[$component] = isset($app["$component.factory"]) ? $app["$component.factory"] : null;
      }
  }

  // `registerConfig` runs automatically to set `options`, `is_themable`, and
  // `theme_options` if needed. The tentatively named globals `app.opts` and
  // `theme.opts` are also published here.
  protected function registerConfig(Application $app)
  {
    // - Alias.
    $config_vars = $app['config.vars'];
    // - Register, process, and store Silexhibit shared application
    //   configuration option group.
    $app->register(new ConfigServiceProvider($app['path.app_web']('config/common.yml'), $config_vars));
    $app->register(new ConfigServiceProvider($app['path.app_web']("config/{$app['env']}.yml"), $config_vars));
    $this->options = $app['app.opts'] = array_merge_recursive(
      $app['merged']('app'),
      $app['merged']($this->app_name)
    );
    // - Check for theme support based on if Silexhibit application option
    //   `theme` is set with a theme name.
    $this->is_themable = isset($app['app.opts']['theme']);
    if ($this->is_themable) {
      // - Register, process, and store Silexhibit application theme
      //   configuration option group.
      $app->register(new ConfigServiceProvider($app['path.theme_web']('config/common.yml'), $config_vars));
      $app->register(new ConfigServiceProvider($app['path.theme_web']("config/{$app['env']}.yml"), $config_vars));
      $this->theme_options = $app['theme.opts'] = $app['merged']("theme.{$app['app.opts']['theme']}");
    }
  }

  // Use `registerTemplater` to add or replace a templater service with given
  // `service_name`. `opts` must contain a `template_path`, and including a
  // `partials_path` enables partials support. The new service gets returned.
  protected function registerTemplater(Application $app, $service_name, $opts)
  {
    $app[$service_name] = $app->share(function () use ($app, $opts) {
      $tpl_opts = array(
        'loader' => new Mustache_Loader_FilesystemLoader($opts['template_path']),
      );
      if (isset($opts['partial_path'])) {
        $tpl_opts['partials_loader'] = new Mustache_Loader_FilesystemLoader($opts['partial_path']);
      }
      if ($app['env'] === 'prod') {
        $tpl_opts['cache'] = $app['path.cache']('mustache');
      }
      // - Uses custom auto-loader.
      return new Mustache_Engine($tpl_opts);
    });
    return $app[$service_name];
  }

  // Assets Support Subroutines
  // --------------------------

  // `setupAssets` runs automatically to prepare for the call to
  // `processAssets`. It will instantiate as much of the necessary pieces of the
  // assets aspect as possible.
  protected function setupAssets()
  {
    // - Initialize `assets_urls`.
    $this->asset_urls = array(
      'css' => array(),
      'head_js' => array(),
      'js' => array(),
    );
    // - Alias.
    $conf = $this->asset_config;
    // - First, our `asset_manager`.
    $am = $this->asset_manager = new AssetManager();
    // - Next, create our filter manager and all our named filters. Provide
    //   configuration as needed. The manager doesn't need to be used by the
    //   controller beyond the local scope.
    $fm = new FilterManager();
    $fm->set('jsmin', new JsCompressorFilter());
    $fm->set('cssmin', new CssCompressorFilter($conf['css_compressor']));
    $fm->set('coffee', new CoffeeScriptFilter($conf['coffee']));
    $fm->set('scss', new ScssFilter());
    // - Also, create our `asset_writer` to write to disk.
    $aw = $this->asset_writer = new AssetWriter($this->paths['dist']);
    // - Also, create our `asset_cache` to work with instances of `AssetCache`.
    $ac = $this->asset_cache = new FilesystemCache($this->paths['cache']);
    // - Finally, create our `asset_factory` and provide the factory with our
    //   managers, as well as a cache-buster if desired.
    $af = $this->asset_factory = new AssetFactory('', $this->debug);
    $af->setFilterManager($fm);
    $af->setAssetManager($am);
    if ($conf['cache_bust']) {
      $af->addWorker(new CacheBustingWorker());
    }
  }
  // By default, `processAssets` runs automatically in `viewWillRender`. After a
  // lengthy process, it adds the URLs in `asset_urls` and ensures they point to
  // properly updated assets.
  protected function processAssets()
  {
    // - Alias.
    $p = $this->paths;
    $app_name = $this->app_name;
    $af = $this->asset_factory;
    $fm = $this->asset_factory->getFilterManager();
    $am = $this->asset_manager;
    $ac = $this->asset_cache;
    // - During debugging, assets aren't minified and so are named differently.
    $min = ($this->debug ? '' : '.min');
    // - Initialize `app_assets` and `theme_assets`. We can do this because PHP
    //   arrays are assign-by-copy by default.
    $app_assets = $theme_assets = array(
      'coffee' => array(),
      'css' => array(),
      'js' => array(),
    );
    // - Populate optional assets via `addOptionalAssets`. For Silex
    //   `app_assets`, if the configuration option group `view` exists in the
    //   application scope, assume its asset-properties are set and specifying
    //   optional assets. For application `theme_assets`, the same applies if
    //   the configuration option group `view` exists in the theme scope.
    if (isset($this->options['view'])) {
      $this->addOptionalAssets($app_assets, $this->options['view']);
    }
    if (isset($this->theme_options) && isset($this->theme_options['view'])) {
      $this->addOptionalAssets($theme_assets, $this->theme_options['view']);
    }
    // - `css_assets` is the final array of Assetic asset and asset collection
    //   objects that represents the list of stylesheets to be compiled in the
    //   final distribution stylesheet. It should tentatively be empty for
    //   assets to be handled via S3 on prod. It starts off with the merged
    //   result of the base library and application stylesheets, as well as the
    //   optional library stylesheets for the application and theme, even if
    //   there aren't any.
    $css_assets = $this->is_prod ? array() : array_merge(
      array(
        // - Include any library css conventionally placed in the `css`
        //   subdirectory of the `lib_web` path.
        new GlobAsset(array(
          "{$p['lib_web']}/css/*.css"
        )),
        // - All Silexhibit application styling is expected to be done using
        //   Sass. Conventionally, Sass imports statements per the stylesheet
        //   manage loading in dependencies. Note the passing in of the `scss`
        //   filter.
        new FileAsset("{$p['app_web']}/scss/style.scss", array($fm->get('scss')))
      ),
      $app_assets['css'],
      $theme_assets['css']
    );
    // - Run the `willRegisterCSSAssets` hook to transform `css_assets` and get
    //   an updated `css_modifier` for the filename, though it may still be
    //   empty.
    list($css_assets, $css_modifier) = $this->willRegisterCSSAssets($css_assets);
    // - Add the stylesheet for the theme if needed.
    if ($this->is_themable) {
      $css_assets[] = new FileAsset("{$p['theme_web']}/scss/style.scss", array($fm->get('scss')));
    }
    // - Our `css_filters` only has the optional minifier when not debugging.
    $css_filters = $this->debug ? array() : array($fm->get('cssmin'));
    // - Our `css_cache` wraps around our assets and filters for distribution.
    //   Tie it to `asset_cache`. Build our distribution filename. And export it
    //   to `asset_manager`.
    $css_cache = new AssetCache(new AssetCollection($css_assets, $css_filters), $ac);
    $css_cache->setTargetPath("${app_name}${css_modifier}.compiled$min.css");
    $am->set('all_css', $css_cache);
    // - Finally, add an `asset_urls` entry for `css`.
    $this->asset_urls['css'][] = "/dist/{$css_cache->getTargetPath()}";
    // - `js_assets` is the final collection of arrays of Assetic asset and
    //   asset collection objects. The arrays are labeled by section and
    //   represent the list of scripts to be compiled in the final distribution
    //   script for each section. The arrays should tentatively be empty for
    //   assets to be handled via S3 on prod.
    $js_assets = array();
    // - Add a `head` section with just the scripts in the `js/head`
    //   subdirectory of the `lib_web` path.
    $js_assets['head'] = $this->is_prod ? array() : array(
      new GlobAsset(array(
        "{$p['lib_web']}/js/head/*.js",
      )),
    );
    // - Add a `lib` section with the root-level scripts in the `js`
    //   subdirectory of the `lib_web` path. Also include any scripts in the
    //   `js/development` subdirectory. Lastly, include any root-level scripts
    //   in the `coffee` subdirectory. Note the passing in of the `coffee`
    //   filter.
    $js_assets['lib'] = $this->is_prod ? array() : array(
      new GlobAsset(array(
        "{$p['lib_web']}/js/*.js",
        "{$p['lib_web']}/js/development/*.js",
      )),
      new GlobAsset(array(
        "{$p['lib_web']}/coffee/*.coffee",
      ), array($fm->get('coffee'))),
    );
    // - Add a `main` section. Include the optional library scripts (js and
    //   coffee) for the application and theme. Note that this isn't in the
    //   `lib` section to ensure the lib distribution file stays consistent
    //   across requests.
    $js_assets['main'] = $this->is_prod ? array() : array_merge(
      $app_assets['coffee'],
      $app_assets['js'],
      // - All Silexhibit application scripting is expected to be done using
      //   CoffeeScript. Note that we specify `main.coffee` again afterwards to
      //   make it an exception that is defined after all the other root-level
      //   scripts, due to it being a bootstrap script. Module scripts are
      //   loaded afterwards.
      array(
        new GlobAsset(array(
          "{$p['app_web']}/coffee/*.coffee",
          "{$p['app_web']}/coffee/main.coffee",
          "{$p['app_web']}/coffee/**/*.coffee",
        ), array($fm->get('coffee'))),
      ),
      $theme_assets['coffee'],
      $theme_assets['js']
    );
    // - Run the `willRegisterJSAssets` hook to transform `js_assets` and get an
    //   updated `js_modifiers` for the filenames that's labeled by the section
    //   names, though they may still be empty.
    list($js_assets, $js_modifiers) = $this->willRegisterJSAssets($js_assets);
    // - Add the script for the theme if needed to `main`.
    if ($this->is_themable) {
      $js_assets['main'][] = new GlobAsset("{$p['theme_web']}/coffee/*.coffee", array($fm->get('coffee')));
    }
    // - Our `js_filters` only has the optional minifier when not debugging.
    $js_filters = $this->debug ? array() : array($fm->get('jsmin'));
    // - `js_map` transforms the section names into filename modifiers. 
    $js_map = array('head' => 'head', 'lib' => 'lib', 'main' => '');
    // - For each section, set `js_cache` to wrap around our assets and filters
    //   for distribution. Tie it to `asset_cache`. Build our distribution
    //   `file_modifier` and filename. And export it to `asset_manager`.
    //   Finally, add an `asset_urls` entry by a hard-coded map depending on
    //   section name.
    foreach ($js_map as $name => $file_modifier) {
      $js_cache = new AssetCache(new AssetCollection($js_assets[$name], $js_filters), $ac);
      $file_modifier = !empty($file_modifier) ? "-$file_modifier" : '';
      $file_modifier .= isset($js_modifiers[$name]) ? $js_modifiers[$name] : '';
      $js_cache->setTargetPath("${app_name}${file_modifier}.compiled$min.js");
      $am->set("{$name}_js", $js_cache);
      if ($name === 'head') {
        $this->asset_urls['head_js'][] = "/dist/{$js_cache->getTargetPath()}";
      } else {
        $this->asset_urls['js'][] = "/dist/{$js_cache->getTargetPath()}";
      }
    }
    // - Finally, have `asset_writer` write to disk the assets from
    //   `asset_manager`. However, on prod, this is tentatively unneeded due to
    //   S3 handling.
    if (!$this->is_prod) {
      $this->asset_writer->writeManagerAssets($am);
    }
  }
  // `addOptionalAssets` is a subroutine for adding library assets from the
  // `lib_web` path to an existing `assets` array when given the relevant
  // configuration `view_options`. The assets are passed in by reference to
  // avoid assign-by-copy if returning the array. The options which should be a
  // collection of arrays of requests labeled by asset `type`. Note the assets
  // must be in the `optional` subdirectory of the subdirectory for the
  // respective asset type.
  protected function addOptionalAssets(array &$assets, array $view_options)
  {
    // - Alias.
    $p = $this->paths;
    $fm = $this->asset_factory->getFilterManager();
    // - Translate `view_options` to added Assetic assets.
    foreach ($view_options as $type => $requests) {
      // - Only add if `assets` already has an array for the `type`, ie. the
      //   type is supported.
      if (!isset($assets[$type])) {
        continue;
      }
      // - Populate `filters` as needed from filter manager.
      $filters = $fm->has($type) ? array($fm->get($type)) : array();
      // - Populate `assets` after generating a `full_path` and creating an
      //   asset object, using `GlobAsset` if needed.
      $assets[$type] = array_map(function ($relative_path) use ($p, $type, $filters) {
        $full_path = "{$p['lib_web']}/$type/optional/$relative_path.$type";
        return (strpos($relative_path, '*') !== false)
          ? new GlobAsset($full_path, $filters) : new FileAsset($full_path, $filters);
      }, $requests);
    }
  }
}
